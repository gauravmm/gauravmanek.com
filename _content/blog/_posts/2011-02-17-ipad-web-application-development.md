---
layout: post
status: publish
published: true
title: iPad Web App - Cache Manifests
author:
  display_name: gauravmm
  login: gauravmm
  email: maneks@gmail.com
  url: ''
author_login: gauravmm
author_email: maneks@gmail.com
wordpress_id: 31
wordpress_url: http://www.gauravmanek.com/blog/?p=31
date: !binary |-
  MjAxMS0wMi0xNyAyMTowNzo1NyArMDgwMA==
date_gmt: !binary |-
  MjAxMS0wMi0xNyAxMzowNzo1NyArMDgwMA==
categories:
- Projects
---
<p>Recently, the Minesweeper3D project was adapted into a web application for iPad - complete with multi-touch gestures and offline caching. It's available <a href="http://www.gauravmanek.com/projects/3dminesweeper/iPad/index_iPad.html" target="_blank">here</a>, with the source code <a href="http://www.gauravmanek.com/projects/3dminesweeper/iPad/" target="_blank">here</a>.</p>
<p>iPad web application can be written to function remarkably like native applications. With the ability to keep a copy of the web app for offline use, web apps are made a lot more useful. Cache manifests are used to make this happen on iOS (see the official document <a href="http://www.w3.org/TR/html5/offline.html" target="_blank">here</a>).</p>
<p>A cache manifest is simply a list of all the files required by the app to run offline. It must be served with the Content-Type header set to text/cache-manifest and the first line must be</p>
<p>[sourcecode language="light"]CACHE MANIFEST[/sourcecode]</p>
<p>. Each relative file path must occur on a separate line, and all text after a # is ignored. Files are updated when the hash of the manifest file changes. A sample manifest file is here:</p>
<p>[code highlight="1"]<br />
CACHE MANIFEST<br />
# Sample Manifest<br />
index.html<br />
arbitrary.js<br />
[/code]</p>
<p>For the Minesweeper3D project, the cache manifest is generated by a simple script. Feel free to modify it for your own use:</p>
<p>[php]<br />
&lt;?php<br />
$files = array(&quot;index_iPad.html&quot;, &quot;display_canvas_iPad.js&quot;, &quot;date.php&quot;, ... );<br />
header(&quot;Content-Type: text/cache-manifest&quot;);<br />
?&gt;<br />
CACHE MANIFEST<br />
# Manifest for Minesweeper3D<br />
# Uses filemtime() to automatically change contents<br />
&lt;?php<br />
foreach ($files as $fn)<br />
	echo $fn.&quot;\n# Mod:&quot;.filemtime($fn).&quot;\n\n&quot;;<br />
?&gt;<br />
[/php]</p>
<p>Since the hash of the manifest file is used to determine if the files need to be redownloaded, even changing the contents of the comments will cause the browser to download the files again. The above script takes advantage of that by including the time that each file was last modified as a comment - any change in the contents of a file will cause the timestamp to change, which will change the hash of the manifest. As the manifest is downloaded each time the application is open, this simple method may prove to be too resource intensive. This can easily addressed by caching the cache file - an amusingly self-referential but effective method.</p>
<p><strong>Version tracking</strong></p>
<p>Debugging the cache system is usually difficult, but here is a simple way to keep track of the current version present in the cache. This solution comes in two parts, and is compatible with the above manifest making script. It comes as an external php script that is just two lines long:</p>
<p>[php]<br />
&lt;?php<br />
header(&quot;Content-type: application/x-javascript&quot;);<br />
echo &quot;var php_date=\&quot;&quot;.date(&quot;r&quot;).&quot;\&quot;;&quot;;<br />
?&gt;<br />
[/php]</p>
<p>It acts as an external JavaScript file that defines the value of the variable php_date to be the date and time that the file was accessed. Since the client only updates the files when the manifest changes, the cache version of this file <em>will not change until the manifest changes</em>. Hence, the date stored in this file is the date at which the file was last downloaded.</p>
<p>[javascript]<br />
function display_initialize(){<br />
	// ...<br />
	document.getElementById(&quot;update_date&quot;).innerHTML = php_date;<br />
}<br />
[/javascript]</p>
<p>Adding a single line to display this date allows us to keep track of the version that is currently being used to display the document. Simple and effective.</p>
<p>A few things to note:</p>
<p>Using the manifest file overrides any other cache directive - HTTP headers, browser configuration, etc. Even pages served over HTTPS are not exempt from this behavior.</p>
<p>The web app can only directly include files mentioned in the manifest. For example, using a &lt;script&gt; tag to include <em>arbitrary.js</em> will only succeed if the manifest file also mentions <em>arbitrary.js</em>. If the file is not mentioned, then it will not be available in the app. Changing this default behavior can be done by appending this to the end of the cache manifest:</p>
<p>[code firstline="5"]<br />
NETWORK:<br />
*<br />
[/code]</p>
<p><strong>Canvas Rendering</strong></p>
<p>Interestingly enough, the canvas rendering is not hardware accelerated. To prevent visible latency in the animations, the variable ani_ActiveMovement in display_canvas_iPad.js disables the rendering of text in the main grid as animation. Uncommenting line 13 from the snippet below enables that "feature". (Ultimately, the problem of lag was solved by changing the frame rate and increasing the "snap" distance.)</p>
<p>[javascript highlight="5,13"]<br />
function ani_moveToTargetZ(tgtZ){<br />
	if(isNaN(tgtZ)) return;<br />
	if(Math.abs(current_z-tgtZ) &amp;lt; 0.1){<br />
		current_z = tgtZ;<br />
		ani_ActiveMovement = false;<br />
		display_Z_slice(current_z);<br />
		return;<br />
	}<br />
	current_z = (current_z + tgtZ)/2;<br />
	display_Z_slice(current_z);<br />
	// Check timer<br />
	clearTimeout(ani_timer1);<br />
	//ani_ActiveMovement=true;<br />
	ani_timer1 = setTimeout(&quot;ani_moveToTargetZ(&quot; + tgtZ + &quot;)&quot;, 40);<br />
}<br />
[/javascript]</p>
<p>Hopefully, hardware rendering will be enabled in a future update.</p>
